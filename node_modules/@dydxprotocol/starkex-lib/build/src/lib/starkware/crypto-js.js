"use strict";
/////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 StarkWare Industries Ltd.                                    //
//                                                                             //
// Licensed under the Apache License, Version 2.0 (the "License").             //
// You may not use this file except in compliance with the License.            //
// You may obtain a copy of the License at                                     //
//                                                                             //
// https://www.starkware.co/open-source-license/                               //
//                                                                             //
// Unless required by applicable law or agreed to in writing,                  //
// software distributed under the License is distributed on an "AS IS" BASIS,  //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    //
// See the License for the specific language governing permissions             //
// and limitations under the License.                                          //
/////////////////////////////////////////////////////////////////////////////////
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.sign = exports.pedersen = exports.starkEc = void 0;
/**
 * Starkware crypto functions implemented in JS.
 *
 * Copied from:
 * https://github.com/starkware-libs/starkex-resources/blob/0f08e6c55ad88c93499f71f2af4a2e7ae0185cdf/crypto/starkware/crypto/signature/signature.js
 *
 * Changes made by dYdX for types and error messages.
 */
const bn_js_1 = __importDefault(require("bn.js"));
const elliptic_1 = require("elliptic");
const _256_1 = __importDefault(require("hash.js/lib/hash/sha/256"));
const constant_points_1 = require("./constant-points");
// Constants.
const zeroBn = new bn_js_1.default(0);
const oneBn = new bn_js_1.default(1);
const maxEcdsaVal = new bn_js_1.default('800000000000000000000000000000000000000000000000000000000000000', 16);
const prime = new bn_js_1.default('800000000000011000000000000000000000000000000000000000000000001', 16);
exports.starkEc = new elliptic_1.ec(new elliptic_1.curves.PresetCurve({
    type: 'short',
    prime: null,
    p: prime.toString(16),
    a: '00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001',
    b: '06f21413 efbe40de 150e596d 72f7a8c5 609ad26c 15c915c1 f4cdfcb9 9cee9e89',
    n: '08000000 00000010 ffffffff ffffffff b781126d cae7b232 1e66a241 adc64d2f',
    hash: _256_1.default,
    gRed: false,
    g: constant_points_1.constantPointsHex[1],
}));
const constantPoints = constant_points_1.constantPointsHex.map((coords) => {
    return exports.starkEc.curve.point(new bn_js_1.default(coords[0], 16), new bn_js_1.default(coords[1], 16));
});
const shiftPoint = constantPoints[0];
/**
 * Compute the pedersen hash of two inputs.
 */
function pedersen(...input) {
    let point = shiftPoint;
    for (let i = 0; i < input.length; i++) {
        let x = input[i];
        if (!(x.gte(zeroBn) && x.lt(prime))) {
            throw new Error(`Input to pedersen hash out of range: ${x.toString(16)}`);
        }
        for (let j = 0; j < 252; j++) {
            const pt = constantPoints[2 + i * 252 + j];
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (point.getX().eq(pt.getX())) {
                throw new Error('Error computing pedersen hash');
            }
            if (x.and(oneBn).toNumber() !== 0) {
                point = point.add(pt);
            }
            x = x.shrn(1);
        }
    }
    return point.getX();
}
exports.pedersen = pedersen;
function sign(ecKeyPair, messageHash) {
    if (!bnInRange(messageHash, zeroBn, maxEcdsaVal)) {
        throw new Error('Message cannot be signed since it exceeds the max length');
    }
    const signature = ecKeyPair.sign(fixHashLength(messageHash));
    const { r, s } = signature;
    const w = s.invm(exports.starkEc.n);
    if (!bnInRange(r, oneBn, maxEcdsaVal) ||
        !bnInRange(s, oneBn, exports.starkEc.n) ||
        !bnInRange(w, oneBn, maxEcdsaVal)) {
        throw new Error('Sanity check failed: an invalid signature was produced');
    }
    return signature;
}
exports.sign = sign;
function verify(publicKey, messageHash, signature) {
    if (!bnInRange(messageHash, zeroBn, maxEcdsaVal)) {
        throw new Error('Message cannot be signed since it exceeds the max length');
    }
    const { r, s } = signature;
    const w = new bn_js_1.default(s, 16).invm(exports.starkEc.n);
    if (!bnInRange(new bn_js_1.default(r, 16), oneBn, maxEcdsaVal)) {
        throw new Error('Signature has invalid r');
    }
    if (!bnInRange(new bn_js_1.default(s, 16), oneBn, exports.starkEc.n)) {
        throw new Error('Signature has invalid s');
    }
    if (!bnInRange(w, oneBn, maxEcdsaVal)) {
        throw new Error('Signature has invalid s (inverse)');
    }
    return publicKey.verify(fixHashLength(messageHash), signature);
}
exports.verify = verify;
function bnInRange(input, lowerBoundInclusive, upperBoundExclusive) {
    return input.gte(lowerBoundInclusive) && input.lt(upperBoundExclusive);
}
function fixHashLength(messageHash) {
    // Convert to string, without leading zeros.
    const hashHex = messageHash.toString(16);
    if (hashHex.length <= 62) {
        // In this case, messageHash should not be transformed, as the byteLength() is at most 31,
        // so delta < 0 (see _truncateToN).
        return messageHash;
    }
    if (hashHex.length !== 63) {
        throw new Error(`Invalid hash length: ${hashHex.length} !== 63`);
    }
    // In this case delta will be 4 so we perform a shift-left of 4 bits.
    return messageHash.ushln(4);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLWpzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9zdGFya3dhcmUvY3J5cHRvLWpzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjs7Ozs7O0FBRWpGOzs7Ozs7O0dBT0c7QUFFSCxrREFBdUI7QUFDdkIsdUNBR2tCO0FBQ2xCLG9FQUE4QztBQUc5Qyx1REFBc0Q7QUFFdEQsYUFBYTtBQUNiLE1BQU0sTUFBTSxHQUFHLElBQUksZUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLE1BQU0sS0FBSyxHQUFHLElBQUksZUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLE1BQU0sV0FBVyxHQUFHLElBQUksZUFBRSxDQUFDLGlFQUFpRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ2xHLE1BQU0sS0FBSyxHQUFHLElBQUksZUFBRSxDQUFDLGlFQUFpRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQy9FLFFBQUEsT0FBTyxHQUFHLElBQUksYUFBYSxDQUN0QyxJQUFJLGlCQUFPLENBQUMsV0FBVyxDQUFDO0lBQ3RCLElBQUksRUFBRSxPQUFPO0lBQ2IsS0FBSyxFQUFFLElBQUk7SUFDWCxDQUFDLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7SUFDckIsQ0FBQyxFQUFFLHlFQUF5RTtJQUM1RSxDQUFDLEVBQUUseUVBQXlFO0lBQzVFLENBQUMsRUFBRSx5RUFBeUU7SUFDNUUsSUFBSSxFQUFFLGNBQU07SUFDWixJQUFJLEVBQUUsS0FBSztJQUNY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