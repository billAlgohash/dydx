"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utf8ToBn = exports.intToBn = exports.decToBn = exports.hexToBn = exports.factToCondition = exports.randomBuffer = exports.normalizeHex32 = exports.bnToHex32 = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const keccak_1 = require("ethereum-cryptography/keccak");
/**
 * Match a hex string with no hex prefix (and at least one character).
 */
const HEX_RE = /^[0-9a-fA-F]+$/;
/**
 * Match a base-10 integer.
 */
const DEC_RE = /^[0-9]+$/;
const BIT_MASK_250 = new bn_js_1.default('3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 16);
/**
 * Convert a BN to a 32-byte hex string without 0x prefix.
 */
function bnToHex32(bn) {
    return normalizeHex32(bn.toString(16));
}
exports.bnToHex32 = bnToHex32;
/**
 * Normalize to a lowercase 32-byte hex string without 0x prefix.
 */
function normalizeHex32(hex) {
    const paddedHex = stripHexPrefix(hex).toLowerCase().padStart(64, '0');
    if (paddedHex.length !== 64) {
        throw new Error('normalizeHex32: Input does not fit in 32 bytes');
    }
    return paddedHex;
}
exports.normalizeHex32 = normalizeHex32;
/**
 * Generate a random Buffer.
 */
function randomBuffer(numBytes) {
    const bytes = [];
    for (let i = 0; i < numBytes; i++) {
        bytes[i] = Math.floor(Math.random() * 0xff);
    }
    return Buffer.from(bytes);
}
exports.randomBuffer = randomBuffer;
/**
 * Create a "condition" Buffer (for a conditional transfer) from a factRegistry address and a fact.
 */
function factToCondition(factRegistryAddress, fact) {
    // Get Buffer equivalent of encode.packed(factRegistryAddress, fact).
    const combinedHex = `${factRegistryAddress}${normalizeHex32(fact)}`;
    const combinedBuffer = Buffer.from(stripHexPrefix(combinedHex), 'hex');
    // Hash the data, mask by 250 bits, and return the hex string equivalent.
    const hashedData = (0, keccak_1.keccak256)(combinedBuffer);
    const hashBN = hexToBn(hashedData.toString('hex'));
    const maskedHashBN = hashBN.and(BIT_MASK_250);
    return maskedHashBN.toString(16);
}
exports.factToCondition = factToCondition;
// ============ Creating BNs ============
/**
 * Convert a hex string with optional 0x prefix to a BN.
 */
function hexToBn(hex) {
    return new bn_js_1.default(stripHexPrefix(hex), 16);
}
exports.hexToBn = hexToBn;
/**
 * Convert a decimal string to a BN.
 */
function decToBn(dec) {
    if (!dec.match(DEC_RE)) {
        throw new Error('decToBn: Input is not a base-10 integer');
    }
    return new bn_js_1.default(dec, 10);
}
exports.decToBn = decToBn;
/**
 * Convert an integer number to a BN.
 */
function intToBn(int) {
    if (!Number.isInteger(int)) {
        throw new Error('intToBn: Input is not an integer');
    }
    return new bn_js_1.default(int, 10);
}
exports.intToBn = intToBn;
/**
 * Convert a string to a BN equal to the left-aligned UTF-8 representation with a fixed bit length.
 *
 * The specified numBits is expected to be a multiple of four.
 */
function utf8ToBn(s, numBits) {
    if (numBits % 4 !== 0) {
        throw new Error(`utf8ToBN: numBits=${numBits} is not a multiple of four`);
    }
    const buffer = Buffer.from(s);
    const hex = buffer.toString('hex');
    const paddedHex = hex.padEnd(numBits / 4, '0');
    if (paddedHex.length !== numBits / 4) {
        throw new Error(`utf8ToBN: Input does not fit in numBits=${numBits} bits`);
    }
    return new bn_js_1.default(paddedHex, 16);
}
exports.utf8ToBn = utf8ToBn;
// ============ Helper Functions ============
function stripHexPrefix(hex) {
    const hexNoPrefix = hex.replace(/^0x/, '');
    if (!hexNoPrefix.match(HEX_RE)) {
        throw new Error('stripHexPrefix: Input is not a hex string');
    }
    return hexNoPrefix;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrREFBdUI7QUFDdkIseURBQXlEO0FBRXpEOztHQUVHO0FBQ0gsTUFBTSxNQUFNLEdBQUcsZ0JBQWdCLENBQUM7QUFFaEM7O0dBRUc7QUFDSCxNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUM7QUFFMUIsTUFBTSxZQUFZLEdBQUcsSUFBSSxlQUFFLENBQUMsaUVBQWlFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFFbkc7O0dBRUc7QUFDSCxTQUFnQixTQUFTLENBQUMsRUFBTTtJQUM5QixPQUFPLGNBQWMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUZELDhCQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixjQUFjLENBQUMsR0FBVztJQUN4QyxNQUFNLFNBQVMsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN0RSxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssRUFBRSxFQUFFO1FBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztLQUNuRTtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFORCx3Q0FNQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLFFBQWdCO0lBQzNDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztJQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2pDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUM3QztJQUNELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBTkQsb0NBTUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLGVBQWUsQ0FDN0IsbUJBQTJCLEVBQzNCLElBQVk7SUFFWixxRUFBcUU7SUFDckUsTUFBTSxXQUFXLEdBQVcsR0FBRyxtQkFBbUIsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUM1RSxNQUFNLGNBQWMsR0FBVyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUUvRSx5RUFBeUU7SUFDekUsTUFBTSxVQUFVLEdBQVcsSUFBQSxrQkFBUyxFQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ3JELE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbkQsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM5QyxPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQWJELDBDQWFDO0FBRUQseUNBQXlDO0FBRXpDOztHQUVHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLEdBQVc7SUFDakMsT0FBTyxJQUFJLGVBQUUsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUZELDBCQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixPQUFPLENBQUMsR0FBVztJQUNqQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7S0FDNUQ7SUFDRCxPQUFPLElBQUksZUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN6QixDQUFDO0FBTEQsMEJBS0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLE9BQU8sQ0FBQyxHQUFXO0lBQ2pDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztLQUNyRDtJQUNELE9BQU8sSUFBSSxlQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3pCLENBQUM7QUFMRCwwQkFLQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixRQUFRLENBQ3RCLENBQVMsRUFDVCxPQUFlO0lBRWYsSUFBSSxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixPQUFPLDRCQUE0QixDQUFDLENBQUM7S0FDM0U7SUFDRCxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQy9DLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxPQUFPLEdBQUcsQ0FBQyxFQUFFO1FBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLE9BQU8sT0FBTyxDQUFDLENBQUM7S0FDNUU7SUFDRCxPQUFPLElBQUksZUFBRSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBZEQsNEJBY0M7QUFFRCw2Q0FBNkM7QUFFN0MsU0FBUyxjQUFjLENBQUMsR0FBVztJQUNqQyxNQUFNLFdBQVcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMzQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7S0FDOUQ7SUFDRCxPQUFPLFdBQVcsQ0FBQztBQUNyQixDQUFDIn0=