"use strict";
/**
 * Helper functions for converting keys and signatures between formats.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeSignature = exports.serializeSignature = exports.isValidPublicKey = exports.asSimplePublicKey = exports.asSimpleSignature = exports.asSimpleKeyPair = exports.asEcKeyPairPublic = exports.asEcKeyPair = void 0;
const lodash_1 = __importDefault(require("lodash"));
const starkware_1 = require("../lib/starkware");
const util_1 = require("../lib/util");
/**
 * Helper for if you want to access additional cryptographic functionality with a private key.
 *
 * Accepts a private key or key pair as hex strings (with or without 0x prefix).
 */
function asEcKeyPair(privateKeyOrKeyPair) {
    const privateKey = typeof privateKeyOrKeyPair === 'string'
        ? privateKeyOrKeyPair
        : privateKeyOrKeyPair.privateKey;
    return starkware_1.starkEc.keyFromPrivate((0, util_1.normalizeHex32)(privateKey));
}
exports.asEcKeyPair = asEcKeyPair;
/**
 * Helper for if you want to access additional cryptographic functionality with a public key.
 *
 * The provided parameter should be the x-coordinate of the public key, or an (x, y) pair.
 * If given as an x-coordinate, then `yCoordinateIsOdd` is required.
 */
function asEcKeyPairPublic(publicKey, yCoordinateIsOdd = null) {
    if (typeof publicKey !== 'string') {
        if (typeof publicKey.x !== 'string' || typeof publicKey.y !== 'string') {
            throw new Error('asEcKeyPairPublic: Public key must be a string or (x, y) pair');
        }
        return starkware_1.starkEc.keyFromPublic({
            x: (0, util_1.normalizeHex32)(publicKey.x),
            y: (0, util_1.normalizeHex32)(publicKey.y),
        });
    }
    if (yCoordinateIsOdd === null) {
        throw new Error('asEcKeyPairPublic: Key was not given as an (x, y) pair, so yCoordinateIsOdd is required');
    }
    const prefix = yCoordinateIsOdd ? '03' : '02';
    const prefixedPublicKey = `${prefix}${(0, util_1.normalizeHex32)(publicKey)}`;
    // This will get the point from only the x-coordinate via:
    // https://github.com/indutny/elliptic/blob/e71b2d9359c5fe9437fbf46f1f05096de447de57/dist/elliptic.js#L1205
    //
    // See also how Starkware infers the y-coordinate:
    // https://github.com/starkware-libs/starkex-resources/blob/1eb84c6a9069950026768013f748016d3bd51d54/crypto/starkware/crypto/signature/signature.py#L164-L173
    return starkware_1.starkEc.keyFromPublic(prefixedPublicKey, 'hex');
}
exports.asEcKeyPairPublic = asEcKeyPairPublic;
/**
 * Converts an `elliptic` KeyPair object to a simple object with publicKey & privateKey hex strings.
 *
 * Returns keys as 32-byte hex strings without 0x prefix.
 */
function asSimpleKeyPair(ecKeyPair) {
    const ecPrivateKey = ecKeyPair.getPrivate();
    if (lodash_1.default.isNil(ecPrivateKey)) {
        throw new Error('asSimpleKeyPair: Key pair has no private key');
    }
    const ecPublicKey = ecKeyPair.getPublic();
    return {
        publicKey: (0, util_1.bnToHex32)(ecPublicKey.getX()),
        publicKeyYCoordinate: (0, util_1.bnToHex32)(ecPublicKey.getY()),
        privateKey: (0, util_1.bnToHex32)(ecPrivateKey),
    };
}
exports.asSimpleKeyPair = asSimpleKeyPair;
/**
 * Converts an `elliptic` Signature object to a simple object with r & s hex strings.
 *
 * Returns r and s as 32-byte hex strings without 0x prefix.
 */
function asSimpleSignature(ecSignature) {
    return {
        r: (0, util_1.bnToHex32)(ecSignature.r),
        s: (0, util_1.bnToHex32)(ecSignature.s),
    };
}
exports.asSimpleSignature = asSimpleSignature;
/**
 * Converts an `elliptic` BasePoint object to a compressed representation: the x-coordinate as hex.
 *
 * Returns a 32-byte hex string without 0x prefix.
 */
function asSimplePublicKey(ecPublicKey) {
    return (0, util_1.bnToHex32)(ecPublicKey.getX());
}
exports.asSimplePublicKey = asSimplePublicKey;
/**
 * Check whether the string or (x, y) pair is a valid public key.
 *
 * Will not throw, always returns a boolean.
 */
function isValidPublicKey(publicKey) {
    try {
        const ecPublicKey = asEcKeyPairPublic(publicKey, false);
        if (!ecPublicKey.validate().result) {
            return false;
        }
        // Return false for out-of-range values and non-hex strings.
        const expectedX = publicKey.x || publicKey;
        const resultX = ecPublicKey.getPublic().getX().toString(16);
        if ((0, util_1.normalizeHex32)(resultX) !== (0, util_1.normalizeHex32)(expectedX)) {
            return false;
        }
        return true;
    }
    catch (error) {
        // Just catch everything. Public keys which throw include 0 and (2^251 + 1).
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/**
 * Convert an (r, s) signature struct to a string.
 */
function serializeSignature(signature) {
    return `${(0, util_1.normalizeHex32)(signature.r)}${(0, util_1.normalizeHex32)(signature.s)}`;
}
exports.serializeSignature = serializeSignature;
/**
 * Convert a serialized signature to an (r, s) struct.
 */
function deserializeSignature(signature) {
    if (signature.length !== 128) {
        throw new Error(`Invalid serialized signature, expected a hex string with length 128: ${signature}`);
    }
    return {
        r: signature.slice(0, 64),
        s: signature.slice(64),
    };
}
exports.deserializeSignature = deserializeSignature;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2hlbHBlcnMvY3J5cHRvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7Ozs7O0FBR0gsb0RBQXVCO0FBRXZCLGdEQUEyQztBQUMzQyxzQ0FHcUI7QUFPckI7Ozs7R0FJRztBQUNILFNBQWdCLFdBQVcsQ0FDekIsbUJBQXFDO0lBRXJDLE1BQU0sVUFBVSxHQUFXLE9BQU8sbUJBQW1CLEtBQUssUUFBUTtRQUNoRSxDQUFDLENBQUMsbUJBQW1CO1FBQ3JCLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLENBQUM7SUFDbkMsT0FBTyxtQkFBTyxDQUFDLGNBQWMsQ0FBQyxJQUFBLHFCQUFjLEVBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUM1RCxDQUFDO0FBUEQsa0NBT0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGlCQUFpQixDQUMvQixTQUE0QyxFQUM1QyxtQkFBbUMsSUFBSTtJQUV2QyxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtRQUNqQyxJQUFJLE9BQU8sU0FBUyxDQUFDLENBQUMsS0FBSyxRQUFRLElBQUksT0FBTyxTQUFTLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUN0RSxNQUFNLElBQUksS0FBSyxDQUFDLCtEQUErRCxDQUFDLENBQUM7U0FDbEY7UUFDRCxPQUFPLG1CQUFPLENBQUMsYUFBYSxDQUFDO1lBQzNCLENBQUMsRUFBRSxJQUFBLHFCQUFjLEVBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUM5QixDQUFDLEVBQUUsSUFBQSxxQkFBYyxFQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7U0FDL0IsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxJQUFJLGdCQUFnQixLQUFLLElBQUksRUFBRTtRQUM3QixNQUFNLElBQUksS0FBSyxDQUNiLHlGQUF5RixDQUMxRixDQUFDO0tBQ0g7SUFFRCxNQUFNLE1BQU0sR0FBRyxnQkFBZ0Is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