/// <reference types="node" />
import { Contracts } from '../lib/Contracts';
import { Address, BigNumberable, CallOptions, SendOptions, TxResult, ZeroExSwapResponse } from '../types';
export declare class Exchange {
    protected contracts: Contracts;
    constructor(contracts: Contracts);
    getAddress(): string;
    getProxyDepositAddress(): string;
    register({ ethAddress, starkKey, signature, }: {
        ethAddress: Address;
        starkKey: string;
        signature: string;
    }, options?: SendOptions): Promise<TxResult>;
    registerAndDeposit({ ethAddress, starkKey, signature, positionId, humanAmount, }: {
        ethAddress: Address;
        starkKey: string;
        signature: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
    }, options?: SendOptions): Promise<TxResult>;
    deposit({ starkKey, positionId, humanAmount, }: {
        starkKey: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
    }, options?: SendOptions): Promise<TxResult>;
    proxyDeposit({ humanAmount, starkKey, positionId, registerUserSignature, }: {
        humanAmount: string;
        starkKey: string;
        positionId: BigNumberable;
        registerUserSignature?: Buffer;
    }, options?: SendOptions): Promise<TxResult>;
    proxyDepositERC20({ humanMinUsdcAmount, starkKey, positionId, zeroExResponseObject, registerUserSignature, getTokenApproval, getExchangeApproval, }: {
        humanMinUsdcAmount: string;
        starkKey: string;
        positionId: BigNumberable;
        zeroExResponseObject: ZeroExSwapResponse;
        registerUserSignature?: Buffer;
        getTokenApproval?: boolean;
        getExchangeApproval?: boolean;
    }, options?: SendOptions): Promise<TxResult>;
    proxyDepositEth({ humanMinUsdcAmount, starkKey, positionId, zeroExResponseObject, registerUserSignature, }: {
        humanMinUsdcAmount: string;
        starkKey: string;
        positionId: BigNumberable;
        zeroExResponseObject: ZeroExSwapResponse;
        registerUserSignature?: Buffer;
    }, options?: SendOptions): Promise<TxResult>;
    /**
     * @description get expected and worst USDC for some amount of input sellToken.
     * @notice For eth pass in 'ETH' as the sellToken.
     */
    estimateConversionAmount({ humanSellAmount, sellToken, decimals, slippagePercentage, }: {
        humanSellAmount: string;
        sellToken: string;
        decimals: number;
        slippagePercentage?: string;
    }): Promise<{
        expectedUsdcHumanAmount: string;
        worstUsdcHumanAmount: string;
        zeroExResponseObject: ZeroExSwapResponse;
    }>;
    withdraw({ starkKey, }: {
        starkKey: string;
    }, options?: SendOptions): Promise<TxResult>;
    withdrawTo({ starkKey, recipient, }: {
        starkKey: string;
        recipient: Address;
    }, options?: SendOptions): Promise<TxResult>;
    forcedWithdrawalRequest({ starkKey, positionId, humanAmount, premiumCost, }: {
        starkKey: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
        premiumCost: boolean;
    }, options?: SendOptions): Promise<TxResult>;
    setERC20Allowance({ tokenAddress, address, amount, }: {
        tokenAddress: Address;
        address: Address;
        amount: BigNumberable;
    }, options?: CallOptions): Promise<TxResult>;
    getEthKey({ starkKey, }: {
        starkKey: string;
    }, options?: CallOptions): Promise<string | null>;
    getWithdrawalBalance({ starkKey, }: {
        starkKey: string;
    }, options?: CallOptions): Promise<string>;
    hasCancellationRequest({ starkKey, vaultId, }: {
        starkKey: string;
        vaultId: BigNumberable;
    }, options?: CallOptions): Promise<boolean>;
    hasForcedWithdrawalRequest({ starkKey, positionId, humanAmount, }: {
        starkKey: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
    }, options?: CallOptions): Promise<boolean>;
    getERC20Allowance({ ownerAddress, spenderAddress, tokenAddress, decimals, }: {
        ownerAddress: Address;
        spenderAddress: Address;
        tokenAddress: Address;
        decimals: number;
    }, options?: CallOptions): Promise<string>;
    private encodeZeroExExchangeData;
}
