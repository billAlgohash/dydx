"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashString = exports.addressesAreEqual = exports.stripHexPrefix = exports.getAllSignatureRotations = exports.fixRawSignature = exports.createTypedSignature = exports.ecRecoverTypedSignature = exports.isValidSigType = exports.EIP712_DOMAIN_STRUCT_NO_CONTRACT = exports.EIP712_DOMAIN_STRING_NO_CONTRACT = exports.EIP712_DOMAIN_STRUCT = exports.EIP712_DOMAIN_STRING = exports.PREPEND_HEX = exports.PREPEND_DEC = exports.PREPEND_PERSONAL = void 0;
const ethers_1 = require("ethers");
const web3_1 = __importDefault(require("web3"));
const types_1 = require("../types");
/**
 * Ethereum signed message prefix without message length.
 */
exports.PREPEND_PERSONAL = '\x19Ethereum Signed Message:\n';
/**
 * Ethereum signed message prefix, 32-byte message, with message length represented as a string.
 */
exports.PREPEND_DEC = '\x19Ethereum Signed Message:\n32';
/**
 * Ethereum signed message prefix, 32-byte message, with message length as a one-byte integer.
 */
exports.PREPEND_HEX = '\x19Ethereum Signed Message:\n\x20';
exports.EIP712_DOMAIN_STRING = 'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)';
exports.EIP712_DOMAIN_STRUCT = [
    { name: 'name', type: 'string' },
    { name: 'version', type: 'string' },
    { name: 'chainId', type: 'uint256' },
    { name: 'verifyingContract', type: 'address' },
];
exports.EIP712_DOMAIN_STRING_NO_CONTRACT = 'EIP712Domain(string name,string version,uint256 chainId)';
exports.EIP712_DOMAIN_STRUCT_NO_CONTRACT = [
    { name: 'name', type: 'string' },
    { name: 'version', type: 'string' },
    { name: 'chainId', type: 'uint256' },
];
const ROTATED_V_VALUES = {
    '00': '1b',
    '01': '1c',
    '1b': '00',
    '1c': '01',
};
// PERSONAL and NO_PREPEND are the only SignatureTypes the frontend app deal with.
const ROTATED_T_VALUES = {
    [`0${types_1.SignatureTypes.NO_PREPEND}`]: `0${types_1.SignatureTypes.PERSONAL}`,
    [`0${types_1.SignatureTypes.PERSONAL}`]: `0${types_1.SignatureTypes.NO_PREPEND}`,
};
function isValidSigType(sigType) {
    switch (sigType) {
        case types_1.SignatureTypes.NO_PREPEND:
        case types_1.SignatureTypes.DECIMAL:
        case types_1.SignatureTypes.HEXADECIMAL:
        case types_1.SignatureTypes.PERSONAL:
            return true;
        default:
            return false;
    }
}
exports.isValidSigType = isValidSigType;
/**
 * Recover the address used to sign a given hash or message.
 *
 * The string `hashOrMessage` is a hash, unless the signature has type SignatureTypes.PERSONAL, in
 * which case it is the signed message.
 */
function ecRecoverTypedSignature(hashOrMessage, typedSignature) {
    const sigType = parseInt(typedSignature.slice(-2), 16);
    let prependedHash;
    switch (sigType) {
        case types_1.SignatureTypes.NO_PREPEND:
            prependedHash = hashOrMessage;
            break;
        case types_1.SignatureTypes.PERSONAL: {
            const fullMessage = `${exports.PREPEND_PERSONAL}${hashOrMessage.length}${hashOrMessage}`;
            prependedHash = web3_1.default.utils.soliditySha3({ t: 'string', v: fullMessage });
            break;
        }
        case types_1.SignatureTypes.DECIMAL:
            prependedHash = web3_1.default.utils.soliditySha3({ t: 'string', v: exports.PREPEND_DEC }, { t: 'bytes32', v: hashOrMessage });
            break;
        case types_1.SignatureTypes.HEXADECIMAL:
            prependedHash = web3_1.default.utils.soliditySha3({ t: 'string', v: exports.PREPEND_HEX }, { t: 'bytes32', v: hashOrMessage });
            break;
        default:
            throw new Error(`Invalid signature type: ${sigType}`);
    }
    const signature = typedSignature.slice(0, -2);
    // Non-null assertion operator is safe, hash is null only on empty input.
    return ethers_1.ethers.utils.recoverAddress(ethers_1.ethers.utils.arrayify(prependedHash), signature);
}
exports.ecRecoverTypedSignature = ecRecoverTypedSignature;
function createTypedSignature(signature, sigType) {
    if (!isValidSigType(sigType)) {
        throw new Error(`Invalid signature type: ${sigType}`);
    }
    return `${fixRawSignature(signature)}0${sigType}`;
}
exports.createTypedSignature = createTypedSignature;
/**
 * Fixes any signatures that don't have a 'v' value of 27 or 28
 */
function fixRawSignature(signature) {
    const stripped = stripHexPrefix(signature);
    if (stripped.length !== 130) {
        throw new Error(`Invalid raw signature: ${signature}`);
    }
    const rs = stripped.substr(0, 128);
    const v = stripped.substr(128, 2);
    switch (v) {
        case '00':
            return `0x${rs}1b`;
        case '01':
            return `0x${rs}1c`;
        case '1b':
        case '1c':
            return `0x${stripped}`;
        default:
            throw new Error(`Invalid v value: ${v}`);
    }
}
exports.fixRawSignature = fixRawSignature;
/**
 * @description get signatures that have a rotated 'v' value, a rotated 't' value, and
 * have both values rotated. If 'v' or 't' cannot be rotated they will keep their original values.
 *
 * @param signature to rotate
 *
 * @throws Error if signature has an invalid length
 *
 * @returns the list of signatures in the following order:
 * [0]: original
 * [1]: rotated 'v' value
 * [2]: rotated 't' value
 * [3]: rotated 'v' and 't' value
 */
function getAllSignatureRotations(signature) {
    const stripped = stripHexPrefix(signature);
    const rs = stripped.slice(0, 128);
    const v = stripped.slice(128, 130);
    const t = stripped.slice(130, 132);
    const rotatedV = ROTATED_V_VALUES[v] || v;
    const rotatedT = ROTATED_T_VALUES[t] || t;
    if (stripped.length !== 132) {
        throw new Error(`Invalid signature: ${signature}`);
    }
    return [
        `0x${stripped}`,
        `0x${rs}${rotatedV}${t}`,
        `0x${rs}${v}${rotatedT}`,
        `0x${rs}${rotatedV}${rotatedT}`,
    ];
}
exports.getAllSignatureRotations = getAllSignatureRotations;
// ============ Byte Helpers ============
function stripHexPrefix(input) {
    if (input.indexOf('0x') === 0) {
        return input.substr(2);
    }
    return input;
}
exports.stripHexPrefix = stripHexPrefix;
function addressesAreEqual(addressOne, addressTwo) {
    if (!addressOne || !addressTwo) {
        return false;
    }
    return (stripHexPrefix(addressOne).toLowerCase() === stripHexPrefix(addressTwo).toLowerCase());
}
exports.addressesAreEqual = addressesAreEqual;
function hashString(input) {
    const hash = web3_1.default.utils.soliditySha3({ t: 'string', v: input });
    if (hash === null) {
        throw new Error(`soliditySha3 input was empty: ${input}`);
    }
    return hash;
}
exports.hashString = hashString;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ldGgtc2lnbmluZy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUFnQztBQUNoQyxnREFBd0I7QUFFeEIsb0NBQW1EO0FBRW5EOztHQUVHO0FBQ1UsUUFBQSxnQkFBZ0IsR0FBVyxnQ0FBZ0MsQ0FBQztBQUV6RTs7R0FFRztBQUNVLFFBQUEsV0FBVyxHQUFXLGtDQUFrQyxDQUFDO0FBRXRFOztHQUVHO0FBQ1UsUUFBQSxXQUFXLEdBQVcsb0NBQW9DLENBQUM7QUFFM0QsUUFBQSxvQkFBb0IsR0FBVyxvRkFBb0YsQ0FBQztBQUVwSCxRQUFBLG9CQUFvQixHQUFHO0lBQ2xDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO0lBQ2hDLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO0lBQ25DLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO0lBQ3BDLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7Q0FDL0MsQ0FBQztBQUVXLFFBQUEsZ0NBQWdDLEdBQVcsMERBQTBELENBQUM7QUFFdEcsUUFBQSxnQ0FBZ0MsR0FBRztJQUM5QyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRTtJQUNoQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRTtJQUNuQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtDQUNyQyxDQUFDO0FBRUYsTUFBTSxnQkFBZ0IsR0FBNEI7SUFDaEQsSUFBSSxFQUFFLElBQUk7SUFDVixJQUFJLEVBQUUsSUFBSTtJQUNWLElBQUksRUFBRSxJQUFJO0lBQ1YsSUFBSSxFQUFFLElBQUk7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