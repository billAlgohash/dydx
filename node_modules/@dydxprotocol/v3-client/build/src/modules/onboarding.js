"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const starkex_lib_1 = require("@dydxprotocol/starkex-lib");
const eth_signing_1 = require("../eth-signing");
const helpers_1 = require("../eth-signing/helpers");
const request_helpers_1 = require("../helpers/request-helpers");
const axios_1 = require("../lib/axios");
const types_1 = require("../types");
const KEY_DERIVATION_SUPPORTED_SIGNING_METHODS = [
    types_1.SigningMethod.TypedData,
    types_1.SigningMethod.MetaMask,
    types_1.SigningMethod.MetaMaskLatest,
    types_1.SigningMethod.CoinbaseWallet,
    types_1.SigningMethod.Personal,
];
class Onboarding {
    constructor(host, web3, networkId) {
        this.host = host;
        this.networkId = networkId;
        this.signer = new eth_signing_1.SignOnboardingAction(web3, networkId);
    }
    // ============ Request Helpers ============
    async post(endpoint, data, ethereumAddress, signature = null, signingMethod = types_1.SigningMethod.TypedData) {
        const message = { action: types_1.OnboardingActionString.ONBOARDING };
        // On mainnet, include an extra onlySignOn parameter.
        if (this.networkId === 1) {
            message.onlySignOn = 'https://trade.dydx.exchange';
        }
        const url = `/v3/${endpoint}`;
        return (0, axios_1.axiosRequest)({
            url: `${this.host}${url}`,
            method: axios_1.RequestMethod.POST,
            data,
            headers: {
                'DYDX-SIGNATURE': signature || await this.signer.sign(ethereumAddress, signingMethod, message),
                'DYDX-ETHEREUM-ADDRESS': ethereumAddress,
            },
        });
    }
    /**
     * Sign the 'key derivation' onboarding message to receive a signature.
     *
     * @param ethereumAddress of the account
     * @param signingMethod Method to use for signing
     * @returns Signature used to derive your STARK key pairs
     */
    async signStarkKeyDerivationMessage(ethereumAddress, signingMethod = types_1.SigningMethod.TypedData) {
        if (!KEY_DERIVATION_SUPPORTED_SIGNING_METHODS.includes(signingMethod)) {
            throw new Error('Unsupported signing method for API key derivation');
        }
        const message = {
            action: types_1.OnboardingActionString.KEY_DERIVATION,
        };
        // On mainnet, include an extra onlySignOn parameter.
        if (this.networkId === 1) {
            message.onlySignOn = 'https://trade.dydx.exchange';
        }
        return this.signer.sign(ethereumAddress, signingMethod, message);
    }
    // ============ Requests ============
    /**
     * @description create a user, account and apiKey in one onboarding request
     *
     * @param {
     * @starkKey is the unique public key for starkwareLib operations used in the future
     * @starkKeyYCoordinate is the Y Coordinate of the unique public key for starkwareLib
     * operations used in the future
     * }
     * @param ethereumAddress of the account
     * @param signature validating the request
     * @param signingMethod for the request
     * @param referredByAffiliateLink of affiliate who referred the user
     * @param country for the user (ISO 3166-1 Alpha-2 Compliant)
     */
    async createUser(params, ethereumAddress, signature = null, signingMethod) {
        return this.post('onboarding', params, ethereumAddress, signature, signingMethod);
    }
    // ============ Key Derivation ============
    /**
     * @description Derive a STARK key pair deterministically from an Ethereum key.
     *
     * This is used by the frontend app to derive the STARK key pair in a way that is recoverable.
     * Programmatic traders may optionally derive their STARK key pair in the same way.
     *
     * @param ethereumAddress Ethereum address of the account to use for signing.
     * @param signingMethod Method to use for signing.
     */
    async deriveStarkKey(ethereumAddress, signingMethod = types_1.SigningMethod.TypedData) {
        const signature = await this.signStarkKeyDerivationMessage(ethereumAddress, signingMethod);
        return (0, starkex_lib_1.keyPairFromData)(Buffer.from((0, helpers_1.stripHexPrefix)(signature), 'hex'));
    }
    /**
     * @description Derive four STARK key pairs deterministically from an Ethereum key, with three
     * of the STARK key pairs using a signature that has had either their 'v' value, 't' value, or
     * both values rotated.
     *
     * This is used by the frontend app to derive the two STARK key pairs to ensure there will be
     * no STARK key mismatch due to a signature's 'v' or 't' value.
     *
     * @param ethereumAddress Ethereum address of the account to use for signing.
     * @param signingMethod Method to use for signing.
     */
    async deriveAllStarkKeys(ethereumAddress, signingMethod = types_1.SigningMethod.TypedData) {
        const signature = await this.signStarkKeyDerivationMessage(ethereumAddress, signingMethod);
        const rotatedSignatures = (0, helpers_1.getAllSignatureRotations)(signature);
        return rotatedSignatures.map((rotatedSignature) => (0, starkex_lib_1.keyPairFromData)(Buffer.from((0, helpers_1.stripHexPrefix)(rotatedSignature), 'hex')));
    }
    /**
     * @description Derive an API key pair deterministically from an Ethereum key.
     *
     * This is used by the frontend app to recover the default API key credentials.
     *
     * @param ethereumAddress Ethereum address of the account to use for signing.
     * @param signingMethod Method to use for signing.
     */
    async recoverDefaultApiCredentials(ethereumAddress, signingMethod = types_1.SigningMethod.TypedData) {
        if (!KEY_DERIVATION_SUPPORTED_SIGNING_METHODS.includes(signingMethod)) {
            throw new Error('Unsupported signing method for API key derivation');
        }
        const message = { action: types_1.OnboardingActionString.ONBOARDING };
        // On mainnet, include an extra onlySignOn parameter.
        if (this.networkId === 1) {
            message.onlySignOn = 'https://trade.dydx.exchange';
        }
        const signature = await this.signer.sign(ethereumAddress, signingMethod, message);
        const buffer = Buffer.from((0, helpers_1.stripHexPrefix)(signature), 'hex');
        // Get secret.
        const rBuffer = buffer.slice(0, 32);
        const rHashedData = (0, request_helpers_1.keccak256Buffer)(rBuffer);
        const secret = rHashedData.slice(0, 30);
        // Get key and passphrase.
        const sBuffer = buffer.slice(32, 64);
        const sHashedData = (0, request_helpers_1.keccak256Buffer)(sBuffer);
        const key = sHashedData.slice(0, 16);
        const passphrase = sHashedData.slice(16, 31);
        return {
            secret: toBase64Url(secret),
            key: uuidFormatKey(key),
            passphrase: toBase64Url(passphrase),
        };
    }
}
exports.default = Onboarding;
function uuidFormatKey(keyBuffer) {
    const key = keyBuffer.toString('hex');
    return [
        key.slice(0, 8),
        key.slice(8, 12),
        key.slice(12, 16),
        key.slice(16, 20),
        key.slice(20, 32),
    ].join('-');
}
function toBase64Url(base64) {
    return base64.toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25ib2FyZGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2R1bGVzL29uYm9hcmRpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyREFHbUM7QUFHbkMsZ0RBQXNEO0FBQ3RELG9EQUFrRjtBQUNsRixnRUFBNkQ7QUFDN0Qsd0NBR3NCO0FBQ3RCLG9DQVNrQjtBQUVsQixNQUFNLHdDQUF3QyxHQUFvQjtJQUNoRSxxQkFBYSxDQUFDLFNBQVM7SUFDdkIscUJBQWEsQ0FBQyxRQUFRO0lBQ3RCLHFCQUFhLENBQUMsY0FBYztJQUM1QixxQkFBYSxDQUFDLGNBQWM7SUFDNUIscUJBQWEsQ0FBQyxRQUFRO0NBQ3ZCLENBQUM7QUFFRixNQUFxQixVQUFVO0lBSzdCLFlBQ0UsSUFBWSxFQUNaLElBQVUsRUFDVixTQUFpQjtRQUVqQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksa0NBQW9CLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRCw0Q0FBNEM7SUFFbEMsS0FBSyxDQUFDLElBQUksQ0FDbEIsUUFBZ0IsRUFDaEIsSUFBUSxFQUNSLGVBQXVCLEVBQ3ZCLFlBQTJCLElBQUksRUFDL0IsZ0JBQStCLHFCQUFhLENBQUMsU0FBUztRQUV0RCxNQUFNLE9BQU8sR0FBcUIsRUFBRSxNQUFNLEVBQUUsOEJBQXNCLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFaEYscURBQXFEO1FBQ3JELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxDQUFDLFVBQVUsR0FBRyw2QkFBNkIsQ0FBQztTQUNwRDtRQUVELE1BQU0sR0FBRyxHQUFXLE9BQU8sUUFBUSxFQUFFLENBQUM7UUFDdEMsT0FBTyxJQUFBLG9CQUFZLEVBQUM7WUFDbEIsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLEVBQUU7WUFDekIsTUFBTSxFQUFFLHFCQUFhLENBQUMsSUFBSTtZQUMxQixJQUFJO1lBQ0osT0FBTyxFQUFFO2dCQUNQLGdCQUFnQixFQUFFLFNBQVMsSUFBSSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUNuRCxlQUFlLEVBQ2YsYUFBYSxFQUNiLE9BQU8sQ0FDUjtnQkFDRCx1QkFBdUIsRUFBRSxlQUFlO2FBQ3pDO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLEtBQUssQ0FBQyw2QkFBNkIsQ0FDM0MsZUFBdUIsRUFDdkIsZ0JBQStCLHFCQUFhLENBQUMsU0FBUztRQUV0RCxJQUFJLENBQUMsd0NBQXdDLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQ3JFLE1BQU0sSUFBSSxLQUFLLENBQUMsbURBQW1ELENBQUMsQ0FBQztTQUN0RTtRQUVELE1BQU0sT0FBTyxHQUFxQjtZQUNoQyxNQUFNLEVBQUUsOEJBQXNCLENBQUMsY0FBYztTQUM5QyxDQUFDO1FBRUYscURBQXFEO1FBQ3JELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxDQUFDLFVBQVUsR0FBRyw2QkFBNkIsQ0FBQztTQUNwRDtRQUVELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQscUNBQXFDO0lBRXJDOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxLQUFLLENBQUMsVUFBVSxDQUNkLE1BS0MsRUFDRCxlQUF1QixFQUN2QixZQUEyQixJQUFJLEVBQy9CLGFBQTZCO1FBTTdCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FDZCxZQUFZLEVBQ1osTUFBTSxFQUNOLGVBQWUsRUFDZixTQUFTLEVBQ1QsYUFBYSxDQUNkLENBQUM7SUFDSixDQUFDO0lBRUQsMkNBQTJDO0lBRTNDOzs7Ozs7OztPQVFHO0lBQ0gsS0FBSyxDQUFDLGNBQWMsQ0FDbEIsZUFBdUIsRUFDdkIsZ0JBQStCLHFCQUFhLENBQUMsU0FBUztRQUV0RCxNQUFNLFNBQVMsR0FBVyxNQUFNLElBQUksQ0FBQyw2QkFBNkIsQ0FDaEUsZUFBZSxFQUNmLGFBQWEsQ0FDZCxDQUFDO1FBRUYsT0FBTyxJQUFBLDZCQUFlLEVBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFBLHdCQUFjLEVBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILEtBQUssQ0FBQyxrQkFBa0IsQ0FDdEIsZUFBdUIsRUFDdkIsZ0JBQStCLHFCQUFhLENBQUMsU0FBUztRQUV0RCxNQUFNLFNBQVMsR0FBVyxNQUFNLElBQUksQ0FBQyw2QkFBNkIsQ0FDaEUsZUFBZSxFQUNmLGFBQWEsQ0FDZCxDQUFDO1FBRUYsTUFBTSxpQkFBaUIsR0FBYSxJQUFBLGtDQUF3QixFQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXhFLE9BQU8saUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUMsZ0JBQXdCLEVBQUUsRUFBRSxDQUFDLElBQUEsNkJBQWUsRUFDeEUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFBLHdCQUFjLEVBQUMsZ0JBQWdCLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FDckQsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsNEJBQTRCLENBQ2hDLGVBQXVCLEVBQ3ZCLGdCQUErQixxQkFBYSxDQUFDLFNBQVM7UUFFdEQsSUFBSSxDQUFDLHdDQUF3QyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUNyRSxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDdEU7UUFFRCxNQUFNLE9BQU8sR0FBcUIsRUFBRSxNQUFNLEVBQUUsOEJBQXNCLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFaEYscURBQXFEO1FBQ3JELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxDQUFDLFVBQVUsR0FBRyw2QkFBNkIsQ0FBQztTQUNwRDtRQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ3RDLGVBQWUsRUFDZixhQUFhLEVBQ2IsT0FBTyxDQUNSLENBQUM7UUFDRixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUEsd0JBQWMsRUFBQyxTQUFTLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU3RCxjQUFjO1FBQ2QsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEMsTUFBTSxXQUFXLEdBQUcsSUFBQSxpQ0FBZSxFQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzdDLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXhDLDBCQUEwQjtRQUMxQixNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNyQyxNQUFNLFdBQVcsR0FBRyxJQUFBLGlDQUFlLEVBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0MsTUFBTSxHQUFHLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDckMsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFN0MsT0FBTztZQUNMLE1BQU0sRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDO1lBQzNCLEdBQUcsRUFBRSxhQUFhLENBQUMsR0FBRyxDQUFDO1lBQ3ZCLFVBQVUsRUFBRSxXQUFXLENBQUMsVUFBVSxDQUFDO1NBQ3BDLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFuTkQsNkJBbU5DO0FBRUQsU0FBUyxhQUFhLENBQUMsU0FBaUI7SUFDdEMsTUFBTSxHQUFHLEdBQVcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QyxPQUFPO1FBQ0wsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2YsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ2hCLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUNqQixHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDakIsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDO0tBQ2xCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUFDLE1BQWM7SUFDakMsT0FBTyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztTQUM3QixPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztTQUNqQixPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQztTQUNuQixPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3pCLENBQUMifQ==